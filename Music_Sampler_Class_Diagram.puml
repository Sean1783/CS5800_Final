@startuml

class Sampler {
    - globalVolume: int
    - presetFileDirectory: String
    - sampleLibraryDirectory: String
    - globalRootPitch: int
    - sampleFile: File
    - audioOutputLine: DataLine
    - settingsChangeObservers: SettingsChangeObserver[0..*]
    + getInstance(): Sampler
    + getVolume() : int
    + getSample() : File
    + getGlobalRootPitch() : int
    + setVolume() : void
    + setGlobalRootPitch() : void
    + setSampleLibraryDirectory(libraryPath: String) : void
    + loadSample(sampleFile: File) : void
    + createSettingsMemento() : SamplerSettingsMemento
    + restoreSettings(previousSettings: SamplerSettingsMemento) : void
    + notifyObserversOfSettingsChange() : void
}
note left: **Singleton**\nControls global and administrative settings. Creates and\nrestores state from SamplerSettingsMemento.\nProvides audio data to system audio data line.


interface MidiEffectChain {
    process(note: MidiMessage) : MidiMessage
}


class BasicMidiGenerator implements MidiEffectChain {
    + process(note: MidiMessage) : MidiMessage
}


class MidiDecorator implements MidiEffectChain {
    - wrappedMidiEffect : MidiEffectChain
    + MidiDecorator(midiEffect: MidiEffectComponent) : MidiDecorator
    + process(note: MidiMessage) : MidiMessage
}
note top: **Decorator**\nObjects receive MidiMessages and apply\nprocessing before providing the processed\ndata to the next decorated object.


class RandomizePitch extends MidiDecorator {
    + process(note: MidiMessage) : MidiMessage
}


class RandomizeVolume extends MidiDecorator {
    + process(note: MidiMessage) : MidiMessage
}


class Arpeggiator extends MidiDecorator {
    + process(note: MidiMessage) : MidiMessage
}


class NoteFactory {
    - notes: String
'    - midiEffectChain: MidiEffectChain
    + getNote(note: MidiMessage): Note
}
note bottom: **Flyweight**\nCreates Note objects based on \nuser input to the system


class Note {
    - pitch: int
    - velocity: int
    + getPitch(): int
    + getVolume(): int
}
note right: Encapsulates user input from key\npresses as pitch and volume values.


class NoteManager {
    - inputLine : Scanner
    - noteFactory: NoteFactory
    - noteBuffer: Note[]
    - effectsChain: MidiEffectChain
    + getNoteBuffer : Note[]
    + isValidInput(input : SystemInput) : boolean
}
note bottom: Receives input messages from System.\nGets processed data from MidiEffectChain\nand requests Note objects from NoteFactory.


class Voice implements SettingsChangeObserver {
    - level: int
    - rootPitch: int
    - isIdle: boolean
    - voiceAudioDataBuffer: byte[]
    - voiceDataConsolidator: VoiceDataConsolidator
    + generateAudioData(note: Note) : void
    + writeToBuffer(): void
    + onSettingsChange() : void
}
note left of Voice: Writes audio data to VoiceDataConsolidator\n buffers. Observes Sampler for changes to pitch and volume.


class VoiceManager {
    - voicePool: Voice[1..4]
    - noteManager: NoteManager
    + delegateNoteToAvailableVoice(note: Note): void
    + createVoice(): void
}
note right: Creates Voice objects.\nGets Note objects from NoteManager and \ndistributes them to idle Voice objects.


class VoiceDataConsolidator {
    - voiceAudioDataBuffers: byte[1..4][ ]
    - effectsChain: AudioEffect
    + getSummedData() : byte[]
    + sumVoiceAudioDataBuffers() : byte[]
    + sendAudioToAudioEffectChain(effectChain: AudioEffect) : void
}
note bottom: Combines audio data generated by Voice objects into a \nsingle buffer for every global clock time step and sends it\nto the effects chain.


class Sample {
    - file: File
    - fileType: String
    - filePath: String
    + getFile(): File
}


class AudioEffectChain {
    - effectChain: AudioEffect [0..*]
    - settingsChangeObservers: SettingsChangeObserver [0..*]
    - effectFactory: AudioEffectFactory
    - sampler: Sampler
    + addEffect(effectType: String): void
    + removeEffect(effectType: String): void
    + rebuildEffectChain(): void
    + createSettingsMemento() : EffectsChainSettingsMemento
    + restoreSettings(previousSettings: EffectsChainSettingsMemento) : void
    + notifyObserversOfSettingsChange() : void
}
note right: Maintains an effects chain.\nCreates and restores state from\nEffectsChainSettingsMemento.


interface AudioEffect {
    setNextEffect(nextEffect: AudioEffect) : void
    processAudio(audioDataBuffer: byte []) : byte []
}
note right: Interface for AudioEffectProcess chain of responsibility.


class AudioEffectProcess implements AudioEffect, SettingsChangeObserver {
    - nextEffect: AudioEffect
    - audioOutputLine: DataLine
    + setNextEffect(nextEffect: AudioEffect) : void
    + processAudio(audioDataBuffer: byte []) : byte []
    +onSettingsChange() : void

}
note left: **Chain of responsibility**\nAll AudioEffectProcess objects process audio data and give\nprocessed audio data to their nextEffect object or give\nit to the output data line for the system to turn into sound.
note right of AudioEffectProcess: These objects apply processing to\nthe audio data they're passed.


interface AudioEffectFactory {
    + createAudioEffect(effectType: String) : AudioEffect
}
note right: **Factory**\nInterface for creation of AudioEffect objects.


class ConcreteAudioEffectFactory implements AudioEffectFactory {
    + createAudioEffect(effectType: String) : AudioEffect
}
note right: Contains logic for creation of AudioEffect objects.


class Reverb extends AudioEffectProcess {
    + processAudio(audioDataBuffer: byte []) : byte []
}


class Delay extends AudioEffectProcess {
    + processAudio(audioDataBuffer: byte []) : byte []
}


class Chorus extends AudioEffectProcess {
    + processAudio(audioDataBuffer: byte []) : byte []
}


interface SettingsChangeObserver {
    + onSettingsChange() : void
}
note right: **Observer**


class SamplerSettingsMemento {
    - sampleFilePath: String
    - globalVolume: int
    - globalRootPitch: int
    - numberOfVoices: int
}
note left: **Memento**


class EffectsChainSettingsMemento {
    - audioEffectChain; String[0..*]
    - midiEffectChain; String[0..*]
}
note left: **Memento**


class ConsolidatedSettings {
    - samplerSettings: SamplerSettingsMemento
    - effectsChainSettings: EffectsChainSettingsMemento
}


class SettingsUndoRedoManager {
    - originatorSampler: Sampler
    - originatorEffects: AudioEffectChain
    - stateHistory: ConsolidatedSettings [0..*]
    - currentStateIndex: int
    + onSettingsChange() : void
    + undoState() : void
    + redoState() : void
}
note right: Manages list of previous system states and\ntells Sampler and AudioEffectChain when to\nrestore a state.


Sample "1" -o "1" Sampler
Sample <-- Voice

'Note and Voice
NoteFactory "1" --* "1" NoteManager
Note "1..128" --o "1" NoteFactory
VoiceManager o-- NoteManager
Voice "1..4" ---* "1" VoiceManager
Voice ---> Note
Voice o--> VoiceDataConsolidator

'SettingsUndoRedoManager
SamplerSettingsMemento <-- Sampler
ConsolidatedSettings "0..*" --* "1" SettingsUndoRedoManager
SamplerSettingsMemento "1" --o "1" ConsolidatedSettings
EffectsChainSettingsMemento "1" --o "1" ConsolidatedSettings
SettingsUndoRedoManager ..|> SettingsChangeObserver
SettingsUndoRedoManager --> AudioEffectChain
Sampler <-- SettingsUndoRedoManager
Sampler "1" o-- "0..*" SettingsChangeObserver
EffectsChainSettingsMemento <-- AudioEffectChain
SettingsChangeObserver "0..*" --o "1" AudioEffectChain

'Audio and MIDI effects
AudioEffect "0..*" --o "1" AudioEffectChain
AudioEffect <---o  AudioEffectProcess
VoiceDataConsolidator o---> AudioEffect
AudioEffectChain o-- AudioEffectFactory
ConcreteAudioEffectFactory -> AudioEffect
MidiEffectChain --o NoteManager

@enduml